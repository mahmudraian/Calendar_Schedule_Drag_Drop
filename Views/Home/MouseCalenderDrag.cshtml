@{
    var lines = ViewBag.Lines as List<WebApplication1.Models.SewingLineDto>;
    var linesJson = Newtonsoft.Json.JsonConvert.SerializeObject(lines);
    var tasks = ViewBag.Tasks as List<WebApplication1.Models.PlanProductionModel>;
    var tasksJson = Newtonsoft.Json.JsonConvert.SerializeObject(tasks);
    DateTime startDate = ViewBag.StartDate;
    DateTime endDate = ViewBag.EndDate;
    int workingHours = 10; // daily working hours
}
@*<style>
        :root {
            --line-width: 180px;
            --cell-width: 120px;
    /*        --row-height: 55px;*/
        }

        /* Wrapper */
        .calendar-wrapper {
            overflow-x: auto;
            overflow-y: auto;
            border: 1px solid #ccc;
    /*        max-height: 550px;*/
        }

        /* Header */
        .calendar-header {
            position: sticky;
            top: 0;
            z-index: 100000;
            background-color: #f8f9fa;
            border-bottom: 2px solid #ddd;
        }

        /* Header + rows must match width */
        .calendar-header,
        .calendar-row {
            display: flex;
    /*        flex-wrap: nowrap;*/
            min-width: max-content;
            position: relative;
        }

        /* Body */
        .calendar-body {
            display: block;
        }

        .calendar-row {
            max-height: 55px;
        }

        .calendar-header .cell::after {
            background: #ddd;
        }

        .calendar-header .cell {
            display: flex;
            flex-direction: column;
            justify-content: center;
            font-weight: 600;
        }


        .row {
            display: flex;
            flex-wrap: nowrap;
            max-height: var(--row-height);
            position: relative;
        }

            /* solid row border */
            .row::after {
                content: "";
                position: absolute;
                left: 0;
                right: 0;
                bottom: 0;
                height: 1px;
                background: #dcdcdc;
            }




        /* line column */
        .line-name {
            width: var(--line-width);
            min-width: var(--line-width);
            flex-shrink: 0;
            padding: 10px;
            background: #fafafa;
            border-right: 1px solid #ddd;
            font-weight: 600;
            border-bottom: 1px solid #e9d7d7;
            position: sticky;
            left: 0;
            z-index: 5000000;
        }

        /* calendar cell */
        .cell {
            width: var(--cell-width);
            min-width: var(--cell-width);
            flex-shrink: 0;
            position: relative;
            border-bottom: 1px solid #e9d7d7;
        }

            /* vertical grid lines */
            .cell::after {
                content: "";
                position: absolute;
                top: 0;
                bottom: 0;
                right: 0;
                width: 1px;
                background-color: #e0e0e0; /* slightly darker */
                pointer-events: none;
            }



        /* Sunday */
        .disabled-day {
            background: #f3f3f3;
        }

    /*    .task {
            position: absolute;
            top: 5px;
            height: calc(var(--row-height));
            line-height: calc(var(--row-height) - 10px);
            background-color: #F5AFAF;
            z-index: 5;
            border:1px solid;
            padding:1px;
        }*/

        .task {
            height: 30px;
            background: #ff6600;
            color: #fff;
            font-size: 12px;
            z-index: 10;
            border-radius: 4px;
            cursor: pointer;
            position: absolute;
        }
        .task-preview {
            opacity: 0.5;
            border: 2px dashed #333;
            z-index: 9999;
        }


    </style>*@

<style>
    :root {
        --line-width: 180px;
        --cell-width: 80px;
        --row-height: 55px;
    }

    /* Scrollable calendar body */
    .calendar-wrapper {
        overflow: auto;
        border: 1px solid #ccc;
        position: relative;
        height: 100vh;
    }

    /* Header (sticky top inside wrapper) */
    .calendar-header {
        display: flex;
        position: sticky;
        top: 0;
        z-index: 1000;
        background: #f8f9fa;
        border-bottom: 2px solid #ddd;
        min-width: max-content;
        height: auto !important;
    }

    /* Calendar rows */
    .calendar-row {
        display: flex;
        min-width: max-content;
        height: auto !important;
        position: relative;
    }

    /* Sticky left column (line name) */
    .line-name {
        width: var(--line-width);
        min-width: var(--line-width);
        flex-shrink: 0;
        padding: 10px;
        background: #fafafa;
        font-weight: 600;
        border-right: 1px solid #ddd;
        border-bottom: 1px solid #e9d7d7;
        position: sticky;
        left: 0;
        z-index: 900;
    }

    /* Header cell */
    /*    .calendar-header .cell {
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: 600;
    }*/

    .calendar-header .cell {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 6px 4px;
        text-align: center;
        line-height: 1.2;
    }

    /* Calendar cell */
    .cell {
        width: var(--cell-width);
        min-width: var(--cell-width);
        flex-shrink: 0;
        position: relative;
        border-bottom: 1px solid #e9d7d7;
    }

        /* Vertical grid line */
        .cell::after {
            content: "";
            position: absolute;
            top: 0;
            bottom: 0;
            right: 0;
            width: 1px;
            background: #e0e0e0;
            pointer-events: none;
        }

    /* Header grid line darker */
    .calendar-header .cell::after {
        background: #ccc;
    }

    .calendar-body {
        height: auto;
        min-height: unset;
        height: auto !important;
    }
    /* Row bottom border */
    .calendar-row::after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        height: 1px;
        background: #dcdcdc;
    }

    /* Disabled day (Sunday) */
    .disabled-day {
        background: #f3f3f3;
/*        z-index:22222222222;*/
    }

    /* Task block */
    /*.task {
        position: absolute;
        top: 12px;
        height: 30px;*/
    /*        background: #ff6600;*/
    /*color: #fff;
        font-size: 12px;
        border-radius: 4px;
        cursor: pointer;
        z-index: 10;
    }*/



    /* Drag preview */
    .task-preview {
        /*        opacity: 0.5;*/
        /*        border: 2px dashed #333;*/
        z-index: 9999;
        cursor: grabbing;
    }

    .task {
        position: absolute;
        height: 34px;
        border-radius: 4px;
        overflow: hidden;
        cursor: grab;
        will-change: transform;
    }

    .task-first {
        height: 5px;
    }

    .task-second {
        height: 24px;
        display: flex;
        align-items: center;
        padding-left: 6px;
        color: #fff;
        font-size: 12px;
        white-space: nowrap;
    }

    .task-third {
        height: 5px;
    }

    #dayText {
        font-size: 12px;
        font-weight: 300;
        line-height: 1.2;
    }

    html, body {
        height: 100%;
        margin: 0;
    }

    .calendar-page {
        display: flex;
        height: calc(100vh - 120px); /* header + form height */
        width: 100%;
        overflow: hidden;
    }

    /* SIDEBAR */
    .sidebar {
        width: 280px;
        background: #212529;
        color: #fff;
        overflow-y: auto;
        transition: width 0.25s ease;
    }

        .sidebar.collapsed {
            width: 0;
        }

    /* SIDEBAR HEADER */
    .sidebar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px;
    }

    /* HANDLE */
    .sidebar-handle {
        width: 18px;
        background: #343a40;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
    }

    /* CALENDAR */
    .calendar-area {
        flex: 1;
        overflow: hidden;
    }

    .calendar-wrapper {
        height: 100%;
        width: 100%;
    }
</style>
<div style="margin-bottom:15px;">

    <h3>Sewing Line Calendar</h3>

    <div style="margin-bottom:15px;">
        <form id="dateForm" method="get" action="@Url.Action("MouseCalenderDrag")">
            From: <input type="date" name="FromDate" value="@(startDate.ToString("yyyy-MM-dd"))" />
            To: <input type="date" name="ToDate" value="@(endDate.ToString("yyyy-MM-dd"))" />
            <button type="submit">Load Calendar</button>
            <button type="button" id="btn-tasks">Load Tasks</button>
        </form>

    </div>

    @*<div class="container-fluid">
            <div class="row">
                <div class="col-3 bg-dark text-white p-3" style="height:100vh;overflow-y:auto;">
                        <h4>Order List</h4>
                        <ul id="sidebar-orders"><li>Loading...</li></ul>
                    </div>

                <div class="9">
                    <div class="calendar-wrapper">
                        <div id="calendar-header" class="calendar-header"></div>
                        <div id="calendar-body" class="calendar-body"></div>
                    </div>
                </div>
            </div>
        </div>*@
    <div class="calendar-page">

        <!-- SIDEBAR -->
        <div id="orderSidebar" class="sidebar">
            <div class="sidebar-header">
                <h4>Order List</h4>
                <button id="closeSidebar">❮</button>
            </div>

            <ul id="sidebar-orders">
                <li>Loading...</li>
            </ul>
        </div>

        <!-- OPEN HANDLE -->
        <div id="openSidebar" class="sidebar-handle">❯</div>

        <!-- CALENDAR -->
        <div class="calendar-area">
            <div class="calendar-wrapper">
                <div id="calendar-header" class="calendar-header"></div>
                <div id="calendar-body" class="calendar-body"></div>
            </div>
        </div>

    </div>



</div>

<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<script>
const WORKING_HOURS = @workingHours;
let tasks = @Html.Raw(tasksJson);
let lines = @Html.Raw(linesJson);
    const TOTAL_DAYS = 365 * 2; // 2 years
    const TOTAL_WEEKS = 104; // 2 years
//let draggedTask = null;
//let lastHover = null;

// --- Date Helpers ---
function parseDateSafe(str){
    if(!str) return null;
    if(str instanceof Date) return str;
    const d = new Date(str);
    return isNaN(d.getTime()) ? null : d;
}

function formatYMD(d){
    const date = parseDateSafe(d);
    if(!date) return "";
    return `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}`;
}

function addDays(date,days){
    const d=new Date(date);
    d.setDate(d.getDate()+days);
    return d;
}

function dayDiff(a,b){
    return Math.floor((b - a)/(1000*60*60*24));
}

// --- Calendar Render ---
    function renderCalendar() {
        const fromDate = parseDateSafe($('input[name="FromDate"]').val());
        const toDate = parseDateSafe($('input[name="ToDate"]').val());
        if (!fromDate || !toDate) return;

        const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        const totalDays = dayDiff(fromDate, toDate);

        /* ================= HEADER ================= */
        const header = document.getElementById('calendar-header');
        header.innerHTML = '';

        const headerLine = document.createElement('div');
        headerLine.className = 'line-name';
        headerLine.textContent = 'Line';
        header.appendChild(headerLine);

        for (let i = 0; i <= totalDays; i++) {
            const currentDate = addDays(fromDate, i);

            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.date = formatYMD(currentDate);
            cell.innerHTML = `
            <div id="dayText" >${dayNames[currentDate.getDay()]}</div>
            <div id="dayText">
            ${currentDate.getDate()}/${currentDate.getMonth() + 1}/${currentDate.getFullYear()}
            </div>

        `;

            header.appendChild(cell);
        }

        /* ================= BODY ================= */
        const body = document.getElementById('calendar-body');
        body.innerHTML = '';



        lines.forEach(line => {
            const row = document.createElement('div');
            row.className = 'calendar-row';
            row.dataset.line = line.LINE_ID;
            row.dataset.manpower = line.MAN_POWER;
            row.dataset.manpowercapacity = line.ManWorkLimite;
            row.dataset.efficiency = line.EFFICIENCY;
            console.log("line", line);
            const lineDiv = document.createElement('div');
            lineDiv.className = 'line-name';
            lineDiv.textContent = line.LINE_NAME;
            row.appendChild(lineDiv);

            for (let i = 0; i <= totalDays; i++) {
                const currentDate = addDays(fromDate, i);
                const isSunday = currentDate.getDay() === 0;

                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.date = formatYMD(currentDate);

                if (isSunday) {
                    cell.classList.add('disabled-day');
                }

                row.appendChild(cell);
            }

            body.appendChild(row);
        });
        //renderTasks(fromDate,toDate)
        requestAnimationFrame(() => {
            renderTasks(fromDate, toDate)
        });
    }

        function parseDMY(dateStr) {
            if (!dateStr) return null;

            // supports: "03-01-2026" OR "03 - 01 - 2026"
            const parts = dateStr.includes('-')
                ? dateStr.split('-')
                : dateStr.split(' - ');

            if (parts.length !== 3) return null;

            const day = Number(parts[0]);
            const month = Number(parts[1]);
            const year = Number(parts[2]);

            return new Date(year, month - 1, day);
        }


        // Helper to get days difference (calendar days, not hours)
        function dayDiff(start, end) {
            const msPerDay = 24 * 60 * 60 * 1000;
            return Math.round((end - start) / msPerDay);
        }


        function durationToHours(duration) {
            const days = Math.floor(duration);
            const fraction = duration - days;
            return (days * WORKING_HOURS) + Math.round(fraction * WORKING_HOURS);
        }
        function convertToDMY(dateStr) {
            const [year, month, day] = dateStr.split('-').map(Number);
            const d = String(day).padStart(2, '0');
            const m = String(month).padStart(2, '0');
            const y = year;
            return `${d}-${m}-${y}`;
        }
        const TASK_COLORS = [
            "#FF5733", // red-orange
            "#33B5E5", // light blue
            "#9C27B0", // purple
            "#4CAF50", // green
            "#FFC107", // amber
            "#E91E63", // pink
            "#009688", // teal
            "#3F51B5", // indigo
            "#FF9800", // orange
            "#795548", // brown

            "#8BC34A", // light green
            "#CDDC39", // lime
            "#673AB7", // deep purple
            "#03A9F4", // sky blue
            "#00BCD4", // cyan
            "#F44336", // red
            "#607D8B", // blue grey
            "#FF5722", // deep orange
            "#9E9E9E", // grey
            "#1ABC9C", // turquoise

            "#2ECC71", // emerald
            "#3498DB", // peter river
            "#9B59B6", // amethyst
            "#34495E", // wet asphalt
            "#16A085", // green sea
            "#27AE60", // nephritis
            "#2980B9", // belize hole
            "#8E44AD", // wisteria
            "#C0392B", // pomegranate
            "#F39C12"  // sun flower
        ];


        function getRandomTaskColor() {
            return TASK_COLORS[Math.floor(Math.random() * TASK_COLORS.length)];
        }

        function calculateEstimatedEndDate(startDateStr, startHour, givenDurationDays, lineWorkingHourCapacity, lineManPower, taskQuantity) {
            const totalRequiredHours = Math.ceil(taskQuantity / lineWorkingHourCapacity);
            const maxAllowedHours = givenDurationDays * WORKING_HOURS;
            let hoursToSchedule = totalRequiredHours;
            let currentDate = new Date(startDateStr);
            let currentHour = startHour;

            while (hoursToSchedule > 0) {
                const availableHoursToday = WORKING_HOURS - currentHour;

                if (hoursToSchedule <= availableHoursToday) {
                    currentHour += hoursToSchedule;
                    hoursToSchedule = 0;
                } else {
                    hoursToSchedule -= availableHoursToday;
                    currentDate.setDate(currentDate.getDate() + 1);
                    currentHour = 0;
                }
            }


            //console.log("startHour", startHour);
            // Make endHour 1 to lineWorkingHourCapacity
            if (currentHour === 0) currentHour = lineWorkingHourCapacity;

            return {
                endDate: currentDate.toISOString().split("T")[0],
                endHour: currentHour
            };
        }


        let dayWidth = 0;
        let hourWidth = 0;
        let lineWidth = 180;
        function getLayout() {
            const firstRow = document.querySelector('.calendar-row');
            if (!firstRow) return null;

            const firstCell = firstRow.querySelector('.cell');
            if (!firstCell) return null;

            dayWidth = firstCell.offsetWidth;
            hourWidth = dayWidth / WORKING_HOURS;
            lineWidth = firstRow.querySelector('.line-name')?.offsetWidth || 180;
        }

        //function renderTasks(calendarStart, calendarEnd) {

        //    // Remove old tasks (cheap)
        //    document.querySelectorAll('.task').forEach(t => t.remove());



        //    if (!dayWidth || !hourWidth || !lineWidth) {
        //        getLayout();
        //    }

        //    /* ================= CACHE ROWS ================= */
        //    const rowMap = new Map();
        //    document.querySelectorAll('.calendar-row').forEach(row => {
        //        rowMap.set(row.dataset.line, row);
        //    });

        //    /* ================= FRAGMENTS ================= */
        //    const fragmentMap = new Map();

        //    console.log("task", tasks);
        //    tasks.forEach(task => {

        //        const row = rowMap.get(String(task.line_id));
        //        if (!row) return;



        //        const start = parseDMY(task.start_date);
        //        const end = parseDMY(task.end_date);


        //        const calStartDate = new Date(calendarStart.getFullYear(), calendarStart.getMonth(), calendarStart.getDate());
        //        const calEndDate = new Date(calendarEnd.getFullYear(), calendarEnd.getMonth(), calendarEnd.getDate());

        //        console.log("start date", start);
        //        console.log("end date", end);

        //        console.log("calStartDate date", calStartDate);
        //        console.log("calEndDate date", calEndDate);

        //        if (!start || !end || formatYMD(end) < calStartDate || formatYMD(start) > calEndDate) return;

        //        const startDayIndex = Math.max(0, dayDiff(calendarStart, start));


        //        const left =
        //            lineWidth +
        //            (startDayIndex * dayWidth) +
        //            (task.start_hour * hourWidth);

        //        const totalDays = dayDiff(calendarStart, calendarEnd) + 1;
        //        const remainingDays = totalDays - startDayIndex;

        //        const maxVisibleHours =
        //            (remainingDays * WORKING_HOURS) - task.start_hour;

        //        const visibleHours = Math.min(
        //            durationToHours(task.duration),
        //            maxVisibleHours
        //        );

        //        if (visibleHours <= 0) return;

        //        const width = visibleHours * hourWidth;

        //        /* ================= TASK ================= */
        //        const taskDiv = document.createElement('div');
        //        taskDiv.className = 'task';
        //        taskDiv.draggable = true;

        //        // GPU-friendly movement
        //        taskDiv.style.transform = `translateX(${left}px)`;
        //        taskDiv.style.width = `${Math.max(width, 6)}px`;

        //        /* ONE COLOR */
        //        const taskColor = getRandomTaskColor();

        //        taskDiv.innerHTML = `
        //    <div class="task-first" style="background:#00BCD4;"></div>
        //    <div class="task-second" style="background:#2ECC71;">
        //        <p>Plan-${task.plan_id}</p>
        //    </div>
        //    <div class="task-third" style="background:#607D8B;"></div>
        //`;

        //        /* DATA */
        //        taskDiv.dataset.id = task.plan_id;
        //        taskDiv.dataset.startDate = task.start_date;
        //        taskDiv.dataset.endDate = task.end_date;
        //        taskDiv.dataset.startHour = task.start_hour;
        //        taskDiv.dataset.endHour = task.end_hour;
        //        taskDiv.dataset.duration = task.duration;
        //        taskDiv.dataset.quantity = task.plan_qnty;

        //        /* FRAGMENT */
        //        let fragment = fragmentMap.get(task.line_id);
        //        if (!fragment) {
        //            fragment = document.createDocumentFragment();
        //            fragmentMap.set(task.line_id, fragment);
        //        }

        //        fragment.appendChild(taskDiv);
        //    });


        //    fragmentMap.forEach((fragment, lineId) => {
        //        console.log("fragment", fragment);
        //        const row = rowMap.get(String(lineId));
        //        if (row) row.appendChild(fragment);
        //    });
    //}

    function renderTasks(calendarStart, calendarEnd) {

        // Remove old tasks
        document.querySelectorAll('.task').forEach(t => t.remove());

        if (!dayWidth || !hourWidth || !lineWidth) {
            getLayout();
        }

        const WORKING_HOURS = 10;

        /* ================= ROW CACHE ================= */
        const rowMap = new Map();
        document.querySelectorAll('.calendar-row').forEach(row => {
            rowMap.set(row.dataset.line, row);
        });

        /* ================= NORMALIZE CALENDAR DATES ================= */
        const calStart = new Date(calendarStart);
        calStart.setHours(0, 0, 0, 0);

        const calEnd = new Date(calendarEnd);
        calEnd.setHours(0, 0, 0, 0);

        console.log("calEnd", calEnd);

        const fragmentMap = new Map();

        /* ================= LOOP TASKS ================= */

        let i = 0;
        console.log("task total", tasks.length);
        tasks.forEach(task => {
            i++;
            console.log("console", i);
            const row = rowMap.get(String(task.line_id));
            if (!row) return;

            const start = parseDMY(task.start_date);
            const end = parseDMY(task.end_date);
            if (!start || !end) return;

            const taskStart = new Date(start);
            const taskEnd = new Date(end);
            taskStart.setHours(0, 0, 0, 0);
            taskEnd.setHours(0, 0, 0, 0);

           

            // Skip if fully outside calendar
            if (taskEnd < calStart || taskStart > calEnd) return;

            /* ================= CLIP TO CALENDAR ================= */
            const visibleStartDate = taskStart < calStart ? calStart : taskStart;
            const visibleEndDate = taskEnd > calEnd ? calEnd : taskEnd;

            // Days between visible start and end
            const visibleDays = dayDiff(visibleStartDate, visibleEndDate) + 1;

            // Hours to render
            let totalHours = durationToHours(task.duration);
            console.log("totalHours ===", totalHours);
            console.log("plan id ===", task.plan_id);

            // Remove hours before calendar
            if (taskStart < calStart) {
                totalHours -= dayDiff(taskStart, calStart) * WORKING_HOURS;
            }

            // Clamp to calendar end
            const maxVisibleHours = visibleDays * WORKING_HOURS - (taskStart >= calStart ? task.start_hour : 0);
            const visibleHours = Math.min(totalHours, maxVisibleHours);
            if (visibleHours <= 0) return;

            /* ================= POSITION ================= */
            const dayIndex = dayDiff(calendarStart, visibleStartDate);
            const left = lineWidth + (dayIndex * dayWidth) + (taskStart >= calStart ? task.start_hour * hourWidth : 0);
            const width = visibleHours * hourWidth;

            /* ================= CREATE TASK ================= */
            const taskDiv = document.createElement('div');
            taskDiv.className = 'task';
            taskDiv.draggable = true;

            taskDiv.style.transform = `translateX(${left}px)`;
            taskDiv.style.width = `${width}px`;

            taskDiv.innerHTML = `
            <div class="task-first" style="background:#00BCD4;"></div>
            <div class="task-second" style="background:#2ECC71;">
                <p>Plan-${task.plan_id}</p>
            </div>
            <div class="task-third" style="background:#607D8B;"></div>
        `;

            /* ================= DATASET ================= */
                    taskDiv.dataset.id = task.plan_id;
                    taskDiv.dataset.startDate = task.start_date;
                    taskDiv.dataset.endDate = task.end_date;
                    taskDiv.dataset.startHour = task.start_hour;
                    taskDiv.dataset.endHour = task.end_hour;
                    taskDiv.dataset.duration = task.duration;
                    taskDiv.dataset.quantity = task.plan_qnty;

            /* ================= FRAGMENT ================= */
            let fragment = fragmentMap.get(task.line_id);
            if (!fragment) {
                fragment = document.createDocumentFragment();
                fragmentMap.set(task.line_id, fragment);
            }

            fragment.appendChild(taskDiv);
        });

        /* ================= APPEND ALL ================= */
        fragmentMap.forEach((fragment, lineId) => {
            const row = rowMap.get(String(lineId));
            if (row) row.appendChild(fragment);
        });
    }




    let draggedTask = null;
    let previewTask = null;
    let lastHover = null;
    let isDragging = false;
    let grabOffsetX = 0;
    let grabOffsetY = 0;
    let mouseX = 0;
    let mouseY = 0;
    let duration = null;
    let cachedWidth = null;
    let rafRunning = false;
    let dragTimeout = null;
    let lastHoverCell = null;

    // -------------------- HELPER FUNCTIONS --------------------
    function getHoverInfo(e, row) {
        const rowRect = row.getBoundingClientRect();
        const lineName = row.querySelector(".line-name");
        if (!lineName) return null;

        const lineWidth = lineName.offsetWidth;
        const x = e.clientX - rowRect.left - lineWidth;
        if (x < 0) return null;

        const cells = row.querySelectorAll(".cell");
        if (!cells.length) return null;

        const dayWidth = cells[0].offsetWidth;
        const hourWidth = dayWidth / WORKING_HOURS;

        let dayIndex = Math.floor(x / dayWidth);
        dayIndex = Math.max(0, Math.min(dayIndex, cells.length - 1));

        let hour = Math.floor((x % dayWidth) / hourWidth);
        hour = Math.max(0, Math.min(hour, WORKING_HOURS - 1));

        return {
            row,
            cell: cells[dayIndex],
            dayIndex,
            hour
        };
    }

    function renderPreview() {
        if (!previewTask) {
            rafRunning = false;
            return;
        }
        previewTask.style.transform = `translate3d(${mouseX}px, ${mouseY - grabOffsetY}px, 0)`;
        requestAnimationFrame(renderPreview);
    }

    function showPreviewOptimized(task, dur = null) {
        if (!previewTask) {
            previewTask = task.cloneNode(true);
            previewTask.classList.add("task-preview");
            previewTask.style.pointerEvents = "none";
            previewTask.style.position = "fixed";
            previewTask.style.top = "0";
            previewTask.style.left = "0";
            previewTask.style.willChange = "transform";
            previewTask.style.zIndex = "9999";

            document.body.appendChild(previewTask);
        }

        if (previewTask) {
            document.body.style.cursor = "grabbing";
        }

        if (!cachedWidth) cachedWidth = task.offsetWidth;
        if (!dayWidth) getLayout();

        if (dur !== null) {
            cachedWidth = dur * dayWidth; // adapt based on dayWidth
            previewTask.style.width = `${cachedWidth}px`;
        } else if (!cachedWidth) {
            cachedWidth = task.offsetWidth;
            previewTask.style.width = `${cachedWidth}px`;
        }

        if (!rafRunning) {
            rafRunning = true;
            requestAnimationFrame(renderPreview);
        }
    }

    function cleanupDrag() {
        if (dragTimeout) clearTimeout(dragTimeout);
        dragTimeout = null;

        if (previewTask) {
            previewTask.remove();
            previewTask = null;
        }

        draggedTask = null;
        lastHover = null;
        lastHoverCell = null;
        duration = null;
        cachedWidth = null;
        rafRunning = false;
        isDragging = false;
        document.body.style.userSelect = "";
        document.body.style.cursor = "default";
    }

    // -------------------- TASK MOVE --------------------
    //function moveTaskToRow(taskDiv, newRow, cell, hour, durationHours) {
    //    const dayWidth = cell.offsetWidth;
    //    const hourWidth = dayWidth / WORKING_HOURS;
    //    const lineWidth = newRow.querySelector(".line-name")?.offsetWidth || 180;

    //    const cells = [...newRow.querySelectorAll(".cell")];
    //    const dayIndex = cells.indexOf(cell);

    //    const left = lineWidth + dayIndex * dayWidth + hour * hourWidth;

    //    taskDiv.remove();
    //    newRow.appendChild(taskDiv);

    //    if (durationHours) {
    //        taskDiv.style.width = `${durationHours * hourWidth}px`;
    //    }

    //    taskDiv.style.transform = `translate3d(${left}px, 0, 0)`;

    //    taskDiv.dataset.startDate = cell.dataset.date;
    //    taskDiv.dataset.startHour = hour;
    //    taskDiv.dataset.duration = durationHours;

    //    const totalHours = hour + durationHours;
    //    taskDiv.dataset.endHour = totalHours % WORKING_HOURS;

    //    const endDayOffset = Math.floor(totalHours / WORKING_HOURS);
    //    const endCell = cells[dayIndex + endDayOffset];
    //    if (endCell) taskDiv.dataset.endDate = endCell.dataset.date;

    //    taskDiv.dataset.line = newRow.dataset.line;
    //}

    function moveTaskToRow(taskDiv, lastHover, durationHours) {
        const { row, cell, hour } = lastHover;
        const newRow = row;
        console.log("newRow", newRow);
        const dayWidth = cell.offsetWidth;
        const hourWidth = dayWidth / WORKING_HOURS;
        const lineWidth = newRow.querySelector(".line-name")?.offsetWidth || 180;

       
        console.log("duration Hours from moveTaskToRow", durationHours);

        const cells = [...newRow.querySelectorAll(".cell")];
        const dayIndex = cells.indexOf(cell);

        const left =
            lineWidth +
            (dayIndex * dayWidth) +
            (hour * hourWidth);

        // total hours available in calendar from this day
        const calendarRemainingHours =
            (cells.length - dayIndex) * WORKING_HOURS;

        // Remove from old row
        taskDiv.remove();
        newRow.appendChild(taskDiv);
        console.log("___________________taskDiv____________________")
        console.log("taskDiv", taskDiv);
        console.log("___________________taskDiv____________________")
        // Width based on duration (hours)
        let TemptotalHours = 0;
        if (durationHours) {
            console.log("durationHours", durationHours);
            console.log("hourWidth", hourWidth);
            TemptotalHours = durationHours * WORKING_HOURS;
            // clamp duration so it doesn't exceed calendar
            const visibleHours = Math.min(TemptotalHours, calendarRemainingHours);
            const width = visibleHours * hourWidth;
            taskDiv.style.width = `${width}px`;
           
        }

        // GPU-accelerated move
        taskDiv.style.transform = `translate3d(${left}px, 0, 0)`;


        // 🔹 Update dataset AFTER moving
        taskDiv.dataset.startDate = cell.dataset.date;
        taskDiv.dataset.startHour = hour;
        taskDiv.dataset.duration = durationHours;

        // Calculate end hour / date if needed
        const totalHours = hour + TemptotalHours;
        taskDiv.dataset.endHour = totalHours % WORKING_HOURS;

        // End date
        const endDayOffset = Math.floor(totalHours / WORKING_HOURS);
        const maxDayIndex = cells.length - 1;
        const safeDayIndex = Math.min(dayIndex + endDayOffset, maxDayIndex);
        console.log("day Index", dayIndex);
        console.log("day Index", endDayOffset);
        console.log("max Index", maxDayIndex);
        console.log("safe Day Index", safeDayIndex);
        const endCell = cells[safeDayIndex];
        if (endCell) {
            taskDiv.dataset.endDate = convertToDMY(endCell.dataset.date);
            console.log("convertToDMY(endCell.dataset.date);", convertToDMY(endCell.dataset.date))
            console.log("convertToDMY(endCell.dataset.date);", endCell.dataset.date)
        }

        taskDiv.dataset.line = newRow.dataset.line;

        // Update task data

      

        const planID = parseInt(draggedTask.dataset.id);
        const start_date = convertToDMY(cell.dataset.date);
        const startHour = hour;
        const LineId = parseInt(newRow.dataset.line);
        const EndDate = convertToDMY(endCell.dataset.date);
        const EndHour = taskDiv.dataset.endHour
        const duration = durationHours;
        
        updatePlan(planID, start_date, startHour, EndDate, EndHour, LineId, duration, lastHover);
    }

    // -------------------- GET DURATION --------------------
    //function getDuration(hover, totalQuantity) {
    //    const { row, cell, hour: startHour } = hover;
    //    totalQuantity = 100000;

    //    const manpower = Number(row.dataset.manpower) || 1;
    //    const efficiency = parseFloat(row.dataset.efficiency) || 1;
    //    const hourlyQty = Number(row.dataset.manpowercapacity) || 1;

    //    const effectiveHourlyOutput = efficiency * hourlyQty;
    //    if (effectiveHourlyOutput <= 0) return 1;

    //    const totalHours = totalQuantity / effectiveHourlyOutput;
    //    return Number(totalHours.toFixed(1));
    //}

    function getDuration(hover, totalQuantity) {
        const { row, cell, hour: startHour } = hover;
        
        //convert dataset values to numbers
        const manpower = Number(row.dataset.manpower);
        const efficiency = row.dataset.efficiency || 0;
        const hourlyQty = Number(row.dataset.manpowercapacity) || 0;

       

        console.log("------------Duartion calculation------------------ ");
        console.log("totalQuantity   ", totalQuantity);
        console.log("manpower", manpower);
        console.log("efficiency", parseFloat(efficiency));
        console.log("hourlyQty", hourlyQty);
        console.log("------------Duartion calculation------------------ ");
       

        if (!hourlyQty || !efficiency) return 0;

        // effective hourly output
        const effectiveHourlyOutput = parseFloat(efficiency) * hourlyQty;
        console.log("effectiveHourlyOutput", effectiveHourlyOutput);
        // total hours (DOUBLE)
        const totalHours = totalQuantity / effectiveHourlyOutput;

        console.log("Number(totalHours.toFixed(1))", Number(totalHours.toFixed(1)));

        // return double with 1 decimal (e.g. 30.2)

        if (effectiveHourlyOutput <= 0) return null;

        // Total hours (double)
        const durationHours = Number(totalHours.toFixed(1));

        /* ---------------- END TIME CALCULATION ---------------- */
        const totalStartHours = startHour + durationHours;

        const endDayOffset = Math.floor(totalStartHours / WORKING_HOURS);
        const endHour = Number(Math.floor(totalStartHours % WORKING_HOURS));



        // Calculate end date
        const startDate = new Date(cell.dataset.date);

        const endDate = new Date(startDate);
        endDate.setDate(startDate.getDate() + endDayOffset);

        console.log("manpower", manpower)
        console.log("startDate", startDate);
        console.log("durationHours", durationHours);
        console.log("endDate", endDate);
        console.log("endDayOffset", endDayOffset);
        console.log("totalStartHours", totalStartHours);
        console.log("endHour", endHour)

        return {
            endDate: endDate,
            endHour: endHour,
            duration: durationHours
        };

    }

    // -------------------- MOUSE EVENTS --------------------
    document.addEventListener("mousedown", e => {
        console.log("mouse down");
        const taskEl = e.target.closest(".task");
        if (!taskEl) return;

        draggedTask = taskEl;
        isDragging = true;
        console.log("mouse down", draggedTask);
        const rect = draggedTask.getBoundingClientRect();
        //grabOffsetX = e.clientX - rect.left;
        grabOffsetX = e.clientX - rect.left;
        grabOffsetY = e.clientY - rect.top;

        mouseX = e.clientX;
        mouseY = e.clientY;

        showPreviewOptimized(draggedTask, draggedTask.dataset.duration);




        document.body.style.userSelect = "none";
    });

    document.addEventListener("mousemove", e => {
        if (!isDragging) return;

        mouseX = e.clientX;
        mouseY = e.clientY;

        showPreviewOptimized(draggedTask, duration);

        const row = e.target.closest(".calendar-row");
        if (!row) return;

        const hover = getHoverInfo(e, row);
        if (!hover || !hover.cell) return;

        lastHover = hover;

        if (hover.cell !== lastHoverCell) {
            lastHoverCell = hover.cell;

            if (dragTimeout) clearTimeout(dragTimeout);

            const quantity = Number(draggedTask.dataset.quantity) || 1;
            dragTimeout = setTimeout(() => {
                console.log("Drag pulse 1 sec", duration);
                durationsData = getDuration(hover, quantity);
                duration = durationsData.duration;
                showPreviewOptimized(draggedTask, duration);
            }, 300);
        }
    });

    document.addEventListener("mouseup", e => {
        if (!isDragging) return;
        isDragging = false;

        if (!draggedTask || !lastHover) {
            cleanupDrag();
            return;
        }

        const { row, cell, hour } = lastHover;
        if (!row || !cell) {
            cleanupDrag();
            return;
        }

       

      
        //moveTaskToRow(draggedTask, row, cell, hour, duration || draggedTask.dataset.duration);

        if (duration) {
            //moveTaskToRow(draggedTask, row, cell, hour, duration);
            moveTaskToRow(draggedTask, lastHover, duration);
        }

        cleanupDrag();
    });


 // Order drag and drop
 let draggedOrder = null; // use let, not const
 let dragOrderhover = null;

 // DRAG START for orders
 $(document).on('dragstart', '.draggable-order', function (e) {
     draggedOrder = $(this);

 });

 // DRAG END
 $(document).on('dragend', '.draggable-order', function () {
     draggedOrder = null;
 });

 // Drag over cells
 $(document).on('dragover', '.cell', function (e) {
     e.preventDefault();
     $(this).addClass('cell-hover');

     const row = e.target.closest(".calendar-row");
     if (!row) return;

     const hover = getHoverInfo(e, row);
     if (!hover) return;

     dragOrderhover = hover;


 });

 $(document).on('dragleave', '.cell', function () {
     $(this).removeClass('cell-hover');
 });

 // DROP: create task from order
 $(document).on('drop', '.cell', function (e) {
     e.preventDefault();
     $(this).removeClass('cell-hover');

     if (!draggedOrder) return;
     const orderHover = dragOrderhover;
     console.log("hover", orderHover.hour);
     const lineId = parseInt(orderHover.row.dataset.line);
     const startDate = convertToDMY(orderHover.cell.dataset.date);
     let startHour = orderHover.hour;

     const order = {
         OrderId: parseInt(draggedOrder.find('strong').text().replace('Order #', '')),
         Quantity: parseInt(draggedOrder.data('quantity')) || 10
     };

     console.log("lineId for order ", lineId);
     console.log("startDate for order", startDate);
     console.log("startHour for order", startHour);

     const line = lines.find(l => l.LINE_ID == lineId);
     if (!line) {
         console.error("Line not found for ID:", lineId.LINE_ID);
         return;
     } else {
         console.log("Log for order", line);
     }







     const newTask = createPlanFromOrder(order, orderHover);

     console.log("new task");


     draggedOrder = null;

     const fromDate = parseDateSafe($('input[name="FromDate"]').val());
     const toDate = parseDateSafe($('input[name="ToDate"]').val());
     requestAnimationFrame(() => {
         renderTasks(fromDate, toDate)
     });
 });


        //data
        function LoadOrders() {
            $.ajax({
                url: '/Home/Orders',
                type: 'GET',
                dataType: 'json',
                success: function (data) {
                    let sidebarList = $('#sidebar-orders');
                    sidebarList.empty();

                    if (!data || data.length === 0) {
                        sidebarList.append('<li class="text-white">No orders found.</li>');
                        return;
                    }

                    data.forEach(order => {
                        // Make li draggable
                        let li = $(`
                        <li class="list-group-item bg-dark text-white border-secondary draggable-order"
                            draggable="true"
                            data-orderid="${order.OrderId}"
                            data-quantity="${order.Quantity}">
                            <strong>Order #${order.OrderId}</strong><br>
                            Company: ${order.OrderCompany || ''}<br>
                            Qty: ${order.Quantity} pcs
                        </li>
                    `);



                        sidebarList.append(li);
                    });
                },
                error: function () {
                    $('#sidebar-orders').html('<li class="text-white">Error loading orders.</li>');
                }
            });
        }

    function createPlanFromOrder(order, orderHover) {
        // Validate input
        if (!order || !orderHover) {
            console.error("Missing required parameters to create task");
            return null;
        }

        const lineId = parseInt(orderHover.row.dataset.line);
        const startDate = convertToDMY(orderHover.cell.dataset.date); // make sure this returns valid 'yyyy-mm-dd'
        const startHour = orderHover.hour || 0;

        // Calculate duration for this order
        const durationForOrder = getDuration(orderHover, order.Quantity);
        if (!durationForOrder || !durationForOrder.endDate || !durationForOrder.endHour || !durationForOrder.duration === undefined) {
            console.error("Duration calculation failed:", durationForOrder);
            return null;
        }
        console.log("durationForOrder", durationForOrder);
        // Create the task object
        const task = {
            plan_id: tasks.length + 1,                   // unique id
            JOB_NO: `Task From Order #${order.OrderId}`, // label
            plan_qnty: order.Quantity,
            line_id: lineId,
            SewingLine: null,                            // optional, can fill later
            start_date: startDate,
            end_date: convertToDMY(formatYMD(durationForOrder.endDate)),
            start_hour: startHour,
            end_hour: durationForOrder.endHour,
            ColorCode: 'blue',
            duration: durationForOrder.duration
        };

        console.log("newTask:", task);

        tasks.push(task);
        console.log("total task:", tasks);
        //moveTaskToRow(task, orderHover.row, orderHover.cell, orderHover.hour, durationForOrder.duration);
        return task;
    }


        function getAllPlansfromApi() {
            $.get("http://202.4.125.191/platform_erp/logic-api/index.php/api/planning/line_info/company_id/1/location_id/2/floor_id/0/user/1/date/2025-12-21", function (data) {
                console.log("Plans received:", data);

            }).fail(function (err) {
                console.error("API request failed:", err);
            });
        }


        function exportTasksToExcel() {
        const tasks = @Html.Raw(tasksJson);
        const worksheet = XLSX.utils.json_to_sheet(tasks);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "Tasks");
        XLSX.writeFile(workbook, "Production_Tasks.xlsx");
        }

    function exportLineToExcel() {
        const AllLine = @Html.Raw(linesJson);
        const worksheetLine = XLSX.utils.json_to_sheet(AllLine);
        const workbookLine = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbookLine, worksheetLine, "Lines");
        XLSX.writeFile(workbookLine, "Production_Line.xlsx");
    }

    function updatePlan(planID, startdate, startHour, EndDate, EndHour, LineId, duration, lastHover)
    {

        const task = tasks.find(t => t.plan_id === planID);
        if (!task) return;

        task.start_date = startdate;
        task.start_hour = startHour;
        task.line_id = LineId;
        task.end_date = EndDate;
        task.end_hour = EndHour;
        task.duration = duration;
        console.log("task after update in update method", task)
        AllPlansByLineId(LineId, task, lastHover)
    }

    //function AllPlansByLineId(lineId, updatedTask) {
    //    // Get tasks on the same line (exclude updated task itself)
    //    const lineTasks = tasks
    //        .filter(t => t.line_id === lineId)
    //        .sort((a, b) => {
    //            const dateA = new Date(a.start_date);
    //            const dateB = new Date(b.start_date);

    //            // First sort by date
    //            if (dateA.getTime() !== dateB.getTime()) {
    //                return dateA - dateB;
    //            }

    //            // If same date, sort by hour
    //            return a.start_hour - b.start_hour;
    //        });


    //    const results = [];

    //    let currentStartDate = updatedTask.start_date;
    //    let currentStartHour = updatedTask.start_hour;
    //    let currentEndDate = updatedTask.end_date;
    //    let currentEndHour = updatedTask.end_hour;

    //    console.log("updated task Start", currentStartDate);
    //    console.log("updated task Start Hour", currentStartHour);
    //    console.log("updated task End Date", currentEndDate);
    //    console.log("updated task Start End Hour", currentEndHour);

    //    const updatedStart = toDateTime(
    //        updatedTask.start_date,
    //        updatedTask.start_hour
    //    );

    //    const updatedEnd = toDateTime(
    //        updatedTask.end_date,
    //        updatedTask.end_hour
    //    );

    //    let cursorStart = updatedEnd;
    //    console.clear();
    //    console.log(" updatedTask end_date", updatedTask.end_date);
    //    console.log("endhour", updatedTask.end_hour)
    //    console.log("updatedStart", updatedStart);
    //    console.log("updatedEnd", updatedEnd);
    //    console.log("lineTasks", updatedTask);

    //    console.log("updated task Start", currentStartDate);
    //    console.log("updated task Start Hour", currentStartHour);
    //    console.log("updated task End Date", currentEndDate);
    //    console.log("updated task End Hour", currentEndHour);
    //    for (const task of lineTasks) {
    //        const taskStartDate = task.start_date;
    //        const taskStartHour = task.start_hour;
    //        const taskEndHour = task.end_hour;
    //        const taskEndDate = task.end_date;

    //        const isOverlap =
    //            (

    //                (
    //                    currentStartDate < taskStartDate ||
    //                    (currentStartDate === taskStartDate && (currentStartHour < taskStartHour || currentStartHour > taskStartHour ))
    //                )
    //                &&

    //                (
    //                    currentEndDate > taskEndDate ||
    //                        (currentEndDate === taskEndDate && (currentEndHour > taskEndHour || currentEndHour < taskEndHour))
    //                )
    //            );



    //        if (isOverlap) {
    //            console.log("===============task Start date==============", task.plan_id);
    //            console.log(" task Start date", taskStartDate);
    //            console.log(" task Start Hour", taskStartHour);
    //            console.log(" task End Date", taskEndDate);
    //            console.log(" task  End Hour", taskEndHour);
    //            console.log(" task line id", task.line_id);
    //            console.log(" task line duration", task.duration);


    //        }


    //    }

    //    // Remaining segment after last overlap
    //    if (cursorStart < updatedEnd) {
    //        results.push({
    //            ...updatedTask,
    //            start_date: formatDate(cursorStart),
    //            start_hour: cursorStart.getHours(),
    //            end_date: updatedTask.end_date,
    //            end_hour: updatedTask.end_hour
    //        });
    //    }
    //    console.log("all line sorted");
    //    console.log("result", results);
    //    return results;
    //}

    function AllPlansByLineId(lineId, updatedTask, lastHover) {

        const lineTasks = tasks.filter(t =>
            t.line_id === lineId &&
            t.plan_id !== updatedTask.plan_id
        );

        console.clear();
        console.log(
            "🔍 Checking conflicts for updated plan:",
            updatedTask.plan_id,
            "plan start date:", updatedTask.start_date,
            "plan end date:", updatedTask.end_date
        );

        const updatedStart = toTimelineValue(
            updatedTask.start_date,
            updatedTask.start_hour
        );

        const updatedEnd = toTimelineValue(
            updatedTask.end_date,
            updatedTask.end_hour
        );

        let hasConflict = false;

        for (const task of lineTasks) {

            const taskStart = toTimelineValue(
                task.start_date,
                task.start_hour
            );

            const taskEnd = toTimelineValue(
                task.end_date,
                task.end_hour
            );

            // ✅ ONLY correct overlap rule
            const isConflict =
                updatedStart < taskEnd &&
                updatedEnd > taskStart;

            if (isConflict) {
                hasConflict = true;

                console.log("❌ DIRECT CONFLICT DETECTED");
                console.log("Updated Plan ID:", updatedTask.plan_id);
                console.log("Conflicting Plan ID:", task.plan_id);
                console.log(
                    "Task Range:",
                    `${task.start_date} ${task.start_hour} → ${task.end_date} ${task.end_hour}`
                );
                console.log("-----------------------------------");
                console.log("------------------------- lastHover----------", task);

                const hover = lastHover;
                const durationForOrder = getDuration(hover, task.Quantity);

                task.end_date = convertToDMY(formatYMD(durationForOrder.endDate));
                task.end_hour = durationForOrder.endHour,
                task.start_date = updatedTask.end_date;
                task.start_hour = updatedTask.end_hour;


            }
        }

        if (!hasConflict) {
            console.log("✅ No conflicts detected");
        }

        const fromDate = parseDateSafe($('input[name="FromDate"]').val());
        const toDate = parseDateSafe($('input[name="ToDate"]').val());
        //requestAnimationFrame(() => {
        //    renderTasks(fromDate, toDate)
        //});
       
    }



    function toTimelineValue(dateStr, hour) {
        const [dd, mm, yyyy] = dateStr.split("-").map(Number);

        // Create real date safely
        const date = new Date(Date.UTC(yyyy, mm - 1, dd));

        // Convert working hour to milliseconds
        return date.getTime() + hour * 60 * 60 * 1000;
    }




    function isBefore(d1, h1, d2, h2) {
        return d1 < d2 || (d1 === d2 && h1 < h2);
    }

    function isAfter(d1, h1, d2, h2) {
        return d1 > d2 || (d1 === d2 && h1 > h2);
    }







    function toDateTime(dateStr, hour) {
        const d = new Date(dateStr);
        d.setHours(hour, 0, 0, 0);
        return d;
    }

    function formatDate(date) {
        return date.toISOString().split("T")[0];
    }

   






// --- Init ---
$(document).ready(()=>{
    renderCalendar();
   
    LoadOrders();
    //getAllPlansfromApi()
    $('#btn-tasks').click(() => renderCalendar());

    //exportTasksToExcel();
    //exportLineToExcel();
    const sidebar = document.getElementById("orderSidebar");
    const openBtn = document.getElementById("openSidebar");
    const closeBtn = document.getElementById("closeSidebar");

    closeBtn.onclick = () => {
        sidebar.classList.add("collapsed");
        window.dispatchEvent(new Event("resize")); // important for calendar
    };

    openBtn.onclick = () => {
        sidebar.classList.remove("collapsed");
        window.dispatchEvent(new Event("resize"));
    };

    console.log("date", formatYMD("Mon Dec 01 2025 06:00:00 GMT+0600 (Bangladesh Standard Time)"))
});
</script>
